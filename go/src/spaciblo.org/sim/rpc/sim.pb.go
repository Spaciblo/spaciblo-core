// Code generated by protoc-gen-go.
// source: sim.proto
// DO NOT EDIT!

/*
Package simRPC is a generated protocol buffer package.

It is generated from these files:
	sim.proto

It has these top-level messages:
	Ping
	Ack
	ListSimInfosParams
	SimInfo
	SimInfoList
	ClientMembership
	AvatarMotion
*/
package simRPC

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Ping struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Ping) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Ack struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Ack) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ListSimInfosParams struct {
}

func (m *ListSimInfosParams) Reset()                    { *m = ListSimInfosParams{} }
func (m *ListSimInfosParams) String() string            { return proto.CompactTextString(m) }
func (*ListSimInfosParams) ProtoMessage()               {}
func (*ListSimInfosParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type SimInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Uuid string `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
}

func (m *SimInfo) Reset()                    { *m = SimInfo{} }
func (m *SimInfo) String() string            { return proto.CompactTextString(m) }
func (*SimInfo) ProtoMessage()               {}
func (*SimInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SimInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimInfo) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

type SimInfoList struct {
	Infos []*SimInfo `protobuf:"bytes,1,rep,name=infos" json:"infos,omitempty"`
}

func (m *SimInfoList) Reset()                    { *m = SimInfoList{} }
func (m *SimInfoList) String() string            { return proto.CompactTextString(m) }
func (*SimInfoList) ProtoMessage()               {}
func (*SimInfoList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SimInfoList) GetInfos() []*SimInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type ClientMembership struct {
	ClientUUID string `protobuf:"bytes,1,opt,name=clientUUID" json:"clientUUID,omitempty"`
	SpaceUUID  string `protobuf:"bytes,2,opt,name=spaceUUID" json:"spaceUUID,omitempty"`
	Member     bool   `protobuf:"varint,3,opt,name=member" json:"member,omitempty"`
}

func (m *ClientMembership) Reset()                    { *m = ClientMembership{} }
func (m *ClientMembership) String() string            { return proto.CompactTextString(m) }
func (*ClientMembership) ProtoMessage()               {}
func (*ClientMembership) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ClientMembership) GetClientUUID() string {
	if m != nil {
		return m.ClientUUID
	}
	return ""
}

func (m *ClientMembership) GetSpaceUUID() string {
	if m != nil {
		return m.SpaceUUID
	}
	return ""
}

func (m *ClientMembership) GetMember() bool {
	if m != nil {
		return m.Member
	}
	return false
}

type AvatarMotion struct {
	SpaceUUID   string    `protobuf:"bytes,1,opt,name=spaceUUID" json:"spaceUUID,omitempty"`
	ClientUUID  string    `protobuf:"bytes,2,opt,name=clientUUID" json:"clientUUID,omitempty"`
	Position    []float64 `protobuf:"fixed64,3,rep,packed,name=position" json:"position,omitempty"`
	Orientation []float64 `protobuf:"fixed64,4,rep,packed,name=orientation" json:"orientation,omitempty"`
	Translation []float64 `protobuf:"fixed64,5,rep,packed,name=translation" json:"translation,omitempty"`
	Rotation    []float64 `protobuf:"fixed64,6,rep,packed,name=rotation" json:"rotation,omitempty"`
}

func (m *AvatarMotion) Reset()                    { *m = AvatarMotion{} }
func (m *AvatarMotion) String() string            { return proto.CompactTextString(m) }
func (*AvatarMotion) ProtoMessage()               {}
func (*AvatarMotion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *AvatarMotion) GetSpaceUUID() string {
	if m != nil {
		return m.SpaceUUID
	}
	return ""
}

func (m *AvatarMotion) GetClientUUID() string {
	if m != nil {
		return m.ClientUUID
	}
	return ""
}

func (m *AvatarMotion) GetPosition() []float64 {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *AvatarMotion) GetOrientation() []float64 {
	if m != nil {
		return m.Orientation
	}
	return nil
}

func (m *AvatarMotion) GetTranslation() []float64 {
	if m != nil {
		return m.Translation
	}
	return nil
}

func (m *AvatarMotion) GetRotation() []float64 {
	if m != nil {
		return m.Rotation
	}
	return nil
}

func init() {
	proto.RegisterType((*Ping)(nil), "simRPC.Ping")
	proto.RegisterType((*Ack)(nil), "simRPC.Ack")
	proto.RegisterType((*ListSimInfosParams)(nil), "simRPC.ListSimInfosParams")
	proto.RegisterType((*SimInfo)(nil), "simRPC.SimInfo")
	proto.RegisterType((*SimInfoList)(nil), "simRPC.SimInfoList")
	proto.RegisterType((*ClientMembership)(nil), "simRPC.ClientMembership")
	proto.RegisterType((*AvatarMotion)(nil), "simRPC.AvatarMotion")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SimHost service

type SimHostClient interface {
	// Test whether a sim host is responsive
	HandlePing(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error)
	// Get info about the simulations from the sim host
	ListSimInfos(ctx context.Context, in *ListSimInfosParams, opts ...grpc.CallOption) (*SimInfoList, error)
	// Tell a sim when a client enters and leaves a space
	HandleClientMembership(ctx context.Context, in *ClientMembership, opts ...grpc.CallOption) (*Ack, error)
	// Tell a sim when a user initiates avatar motion
	HandleAvatarMotion(ctx context.Context, in *AvatarMotion, opts ...grpc.CallOption) (*Ack, error)
}

type simHostClient struct {
	cc *grpc.ClientConn
}

func NewSimHostClient(cc *grpc.ClientConn) SimHostClient {
	return &simHostClient{cc}
}

func (c *simHostClient) HandlePing(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/simRPC.SimHost/HandlePing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simHostClient) ListSimInfos(ctx context.Context, in *ListSimInfosParams, opts ...grpc.CallOption) (*SimInfoList, error) {
	out := new(SimInfoList)
	err := grpc.Invoke(ctx, "/simRPC.SimHost/ListSimInfos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simHostClient) HandleClientMembership(ctx context.Context, in *ClientMembership, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/simRPC.SimHost/HandleClientMembership", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simHostClient) HandleAvatarMotion(ctx context.Context, in *AvatarMotion, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/simRPC.SimHost/HandleAvatarMotion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SimHost service

type SimHostServer interface {
	// Test whether a sim host is responsive
	HandlePing(context.Context, *Ping) (*Ack, error)
	// Get info about the simulations from the sim host
	ListSimInfos(context.Context, *ListSimInfosParams) (*SimInfoList, error)
	// Tell a sim when a client enters and leaves a space
	HandleClientMembership(context.Context, *ClientMembership) (*Ack, error)
	// Tell a sim when a user initiates avatar motion
	HandleAvatarMotion(context.Context, *AvatarMotion) (*Ack, error)
}

func RegisterSimHostServer(s *grpc.Server, srv SimHostServer) {
	s.RegisterService(&_SimHost_serviceDesc, srv)
}

func _SimHost_HandlePing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimHostServer).HandlePing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/simRPC.SimHost/HandlePing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimHostServer).HandlePing(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimHost_ListSimInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSimInfosParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimHostServer).ListSimInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/simRPC.SimHost/ListSimInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimHostServer).ListSimInfos(ctx, req.(*ListSimInfosParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimHost_HandleClientMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientMembership)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimHostServer).HandleClientMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/simRPC.SimHost/HandleClientMembership",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimHostServer).HandleClientMembership(ctx, req.(*ClientMembership))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimHost_HandleAvatarMotion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvatarMotion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimHostServer).HandleAvatarMotion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/simRPC.SimHost/HandleAvatarMotion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimHostServer).HandleAvatarMotion(ctx, req.(*AvatarMotion))
	}
	return interceptor(ctx, in, info, handler)
}

var _SimHost_serviceDesc = grpc.ServiceDesc{
	ServiceName: "simRPC.SimHost",
	HandlerType: (*SimHostServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandlePing",
			Handler:    _SimHost_HandlePing_Handler,
		},
		{
			MethodName: "ListSimInfos",
			Handler:    _SimHost_ListSimInfos_Handler,
		},
		{
			MethodName: "HandleClientMembership",
			Handler:    _SimHost_HandleClientMembership_Handler,
		},
		{
			MethodName: "HandleAvatarMotion",
			Handler:    _SimHost_HandleAvatarMotion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sim.proto",
}

func init() { proto.RegisterFile("sim.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 377 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x92, 0x4f, 0x6b, 0xfa, 0x30,
	0x18, 0xc7, 0x7f, 0xb1, 0x5a, 0xf5, 0xa9, 0xf0, 0x1b, 0x99, 0x48, 0x29, 0x63, 0x2b, 0x81, 0x41,
	0x77, 0x11, 0xe6, 0x76, 0xd9, 0xb1, 0xb8, 0x83, 0xc2, 0x04, 0xe9, 0xf0, 0x05, 0xc4, 0xda, 0x69,
	0xd0, 0x34, 0xa5, 0xa9, 0x7b, 0x8d, 0x7b, 0x43, 0xbb, 0x8f, 0x24, 0xad, 0xab, 0x75, 0xb7, 0x7e,
	0xff, 0xe4, 0x93, 0x87, 0x3e, 0x81, 0xbe, 0x64, 0x7c, 0x9c, 0xe5, 0xa2, 0x10, 0xd8, 0x96, 0x8c,
	0x47, 0xcb, 0x29, 0xf1, 0xa0, 0xbd, 0x64, 0xe9, 0x16, 0x63, 0x68, 0xa7, 0x94, 0x27, 0x2e, 0xf2,
	0x51, 0xd0, 0x8f, 0xf4, 0x37, 0xb9, 0x03, 0x2b, 0x8c, 0xf7, 0xd8, 0x85, 0x2e, 0x4f, 0xa4, 0xa4,
	0xdb, 0x2a, 0xad, 0x24, 0x19, 0x02, 0x7e, 0x63, 0xb2, 0x78, 0x67, 0x7c, 0x9e, 0x7e, 0x08, 0xb9,
	0xa4, 0x39, 0xe5, 0x92, 0x3c, 0x42, 0xb7, 0x74, 0xfe, 0xa2, 0x2a, 0xef, 0x78, 0x64, 0x1b, 0xb7,
	0x65, 0x3c, 0xf5, 0x4d, 0x9e, 0xc1, 0x29, 0x8f, 0x28, 0x1e, 0xbe, 0x87, 0x0e, 0x53, 0x40, 0x17,
	0xf9, 0x56, 0xe0, 0x4c, 0xfe, 0x8f, 0xcd, 0xb0, 0xe3, 0xb2, 0x13, 0x99, 0x94, 0xec, 0xe0, 0x6a,
	0x7a, 0x60, 0x49, 0x5a, 0x2c, 0x12, 0xbe, 0x4e, 0x72, 0xb9, 0x63, 0x19, 0xbe, 0x05, 0x88, 0xb5,
	0xb7, 0x5a, 0xcd, 0x5f, 0xcb, 0x7b, 0x6b, 0x0e, 0xbe, 0x81, 0xbe, 0xcc, 0x68, 0x9c, 0xe8, 0xd8,
	0x8c, 0xf0, 0x6b, 0xe0, 0x11, 0xd8, 0x5c, 0xb3, 0x5c, 0xcb, 0x47, 0x41, 0x2f, 0x2a, 0x15, 0xf9,
	0x42, 0x30, 0x08, 0x3f, 0x69, 0x41, 0xf3, 0x85, 0x28, 0x98, 0x48, 0xcf, 0x31, 0xa8, 0x89, 0x39,
	0x1f, 0xa2, 0x75, 0x31, 0x84, 0x07, 0xbd, 0x4c, 0x48, 0xa6, 0x48, 0xae, 0xe5, 0x5b, 0x01, 0x8a,
	0x4e, 0x1a, 0xfb, 0xe0, 0x88, 0x5c, 0x35, 0xa9, 0x8e, 0xdb, 0x3a, 0xae, 0x5b, 0xaa, 0x51, 0xe4,
	0x34, 0x95, 0x07, 0xd3, 0xe8, 0x98, 0x46, 0xcd, 0x52, 0xfc, 0x5c, 0x94, 0x00, 0xdb, 0xf0, 0x2b,
	0x3d, 0xf9, 0x46, 0x7a, 0x3d, 0x33, 0x21, 0x0b, 0xfc, 0x00, 0x30, 0xa3, 0xe9, 0xe6, 0x90, 0xe8,
	0x27, 0x30, 0xa8, 0x7e, 0xb3, 0x52, 0x9e, 0x53, 0xa9, 0x30, 0xde, 0x93, 0x7f, 0x38, 0x84, 0x41,
	0x7d, 0xd5, 0xd8, 0xab, 0xe2, 0xcb, 0x07, 0xe0, 0x5d, 0x37, 0xf6, 0xa5, 0x2a, 0x1a, 0x31, 0x32,
	0xb7, 0x5d, 0x2c, 0xcd, 0xad, 0x0e, 0x34, 0x93, 0xe6, 0x14, 0x2f, 0x80, 0x0d, 0xe2, 0x6c, 0x19,
	0xc3, 0x53, 0xa9, 0xe6, 0x36, 0x8e, 0xae, 0x6d, 0xfd, 0xee, 0x9f, 0x7e, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x22, 0x51, 0x68, 0xc7, 0x04, 0x03, 0x00, 0x00,
}
